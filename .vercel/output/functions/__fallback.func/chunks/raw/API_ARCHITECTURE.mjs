const n="# API Architecture Documentation\n\n## Overview\n\nThe application has been refactored to move all transaction processing logic from the client-side to the server-side (Nitro API layer). This provides better performance, security, and maintainability.\n\n## Architecture Layers\n\n### 1. Data Fetching Layer\n**Location**: `server/utils/googleSheets.ts`\n\n- Handles connection to Google Sheets API\n- Fetches raw transaction data\n- Single source of truth for transaction data\n\n### 2. Transformation Layer\n**Location**: `server/utils/personIdentifier.ts`\n\n- Enriches transactions with person identification (Juliana/Gabriel)\n- Pattern-based matching on Origin field\n- Configurable patterns for easy customization\n\n### 3. Processing Layer\n**Location**: `server/utils/installmentProcessor.ts`\n\n- Parses installment descriptions (e.g., \"Netflix 01/12\")\n- Expands installments across months\n- Groups related installments\n- Generates correct dates for recurring payments\n\n### 4. Filtering Layer\n**Location**: `server/utils/transactionFilters.ts`\n\n- Applies filters based on query parameters\n- Validates filter inputs\n- Supports multiple filter types simultaneously\n\n### 5. API Endpoint\n**Location**: `server/api/transactions.get.ts`\n\n- Orchestrates all layers\n- Handles HTTP requests\n- Validates query parameters\n- Returns filtered, processed data\n\n## API Endpoint Usage\n\n### Base URL\n```\nGET /api/transactions\n```\n\n### Supported Query Parameters\n\n| Parameter | Type | Description | Example |\n|-----------|------|-------------|---------|\n| `person` | string | Filter by Juliana/Gabriel/Ambos | `?person=Gabriel` |\n| `startDate` | string | Start date (YYYY-MM-DD) | `?startDate=2025-01-01` |\n| `endDate` | string | End date (YYYY-MM-DD) | `?endDate=2025-01-31` |\n| `searchTerm` | string | Search in descriptions | `?searchTerm=Netflix` |\n| `origin` | string | Filter by account/card | `?origin=Credit%20Card` |\n| `destination` | string | Filter by category | `?destination=Food` |\n| `processInstallments` | boolean | Enable/disable installment processing | `?processInstallments=false` |\n\n### Example Requests\n\n#### Get all transactions (default behavior)\n```\nGET /api/transactions\n```\n\n#### Get Gabriel's transactions for January 2025\n```\nGET /api/transactions?person=Gabriel&startDate=2025-01-01&endDate=2025-01-31\n```\n\n#### Search for Netflix transactions\n```\nGET /api/transactions?searchTerm=Netflix\n```\n\n#### Get transactions without installment processing\n```\nGET /api/transactions?processInstallments=false\n```\n\n#### Combine multiple filters\n```\nGET /api/transactions?person=Juliana&startDate=2025-01-01&destination=Food&searchTerm=restaurant\n```\n\n## Client-Side Usage\n\n### Using the Composable\n\n```typescript\nimport { useTransactions } from '~/composables/useTransactions'\n\nconst { transactions, loading, error, fetchTransactions } = useTransactions()\n\n// Fetch all transactions\nawait fetchTransactions()\n\n// Fetch with filters\nawait fetchTransactions({\n  person: 'Gabriel',\n  startDate: '2025-01-01',\n  endDate: '2025-01-31'\n})\n\n// Fetch specific category\nawait fetchTransactions({\n  destination: 'Food',\n  searchTerm: 'restaurant'\n})\n```\n\n### Person Filter Integration\n\n```typescript\nimport { usePersonFilter } from '~/composables/usePersonFilter'\nimport { useTransactions } from '~/composables/useTransactions'\n\nconst { selectedPerson, setPersonFilter } = usePersonFilter()\nconst { fetchTransactions } = useTransactions()\n\n// Change person filter\nsetPersonFilter('Gabriel')\n\n// Fetch with new filter\nawait fetchTransactions({ person: selectedPerson.value })\n```\n\n## Data Flow\n\n```\n1. Client Request\n   ↓\n2. API Endpoint (validates params)\n   ↓\n3. Fetch from Google Sheets\n   ↓\n4. Enrich with Person Data\n   ↓\n5. Process Installments (optional)\n   ↓\n6. Apply Filters\n   ↓\n7. Return to Client\n```\n\n## Transaction Object Structure\n\n```typescript\ninterface Transaction {\n  transactionId: string\n  date: string              // YYYY-MM-DD format\n  origin: string            // Account/card name\n  destination: string       // Category\n  description: string       // Transaction description\n  amount: number            // Transaction amount\n  recordedAt: string        // When transaction was recorded\n  remoteId: string          // External ID\n  person?: 'Juliana' | 'Gabriel' | null  // Auto-identified person\n}\n```\n\n## Customization\n\n### Adding Person Patterns\n\nEdit `server/utils/personIdentifier.ts`:\n\n```typescript\nconst JULIANA_PATTERNS = [\n  'juliana',\n  'cartao juliana',\n  // Add your patterns here\n]\n\nconst GABRIEL_PATTERNS = [\n  'gabriel',\n  'conta gabriel',\n  // Add your patterns here\n]\n```\n\n### Adding New Filters\n\n1. Add parameter to `TransactionQueryParams` in `types/transaction.ts`\n2. Create filter function in `server/utils/transactionFilters.ts`\n3. Add to `applyFilters()` function\n4. Update validation in `validateQueryParams()` if needed\n\n### Disabling Installment Processing\n\nPass `processInstallments: false` in query params:\n\n```typescript\nawait fetchTransactions({ processInstallments: false })\n```\n\n## Performance Benefits\n\n1. **Reduced Client-Side Processing**: All heavy computation happens on the server\n2. **Lower Bandwidth**: Only filtered data is sent to client\n3. **Faster Page Loads**: Less JavaScript to execute in browser\n4. **Better Scalability**: Server can handle larger datasets more efficiently\n5. **Cached Results**: Server can implement caching strategies (future enhancement)\n\n## Migration from Old Architecture\n\n### Before (Client-Side Filtering)\n```typescript\n// Old way - fetches all data, filters client-side\nconst { transactions, fetchTransactions } = useTransactions()\nconst { filterTransactionsByPerson } = usePersonFilter()\n\nawait fetchTransactions()\nconst filtered = filterTransactionsByPerson(transactions.value)\n```\n\n### After (Server-Side Filtering)\n```typescript\n// New way - filters server-side, receives only needed data\nconst { transactions, fetchTransactions } = useTransactions()\n\nawait fetchTransactions({ person: 'Gabriel' })\n// transactions.value already contains only Gabriel's transactions\n```\n\n## Error Handling\n\nThe API returns appropriate HTTP status codes:\n\n- `200 OK`: Success\n- `400 Bad Request`: Invalid query parameters\n- `500 Internal Server Error`: Server-side error (Google Sheets, processing, etc.)\n\nExample error response:\n```json\n{\n  \"statusCode\": 400,\n  \"statusMessage\": \"Invalid query parameters\",\n  \"data\": [\n    \"Invalid person filter: InvalidName. Must be one of: Juliana, Gabriel, Ambos\"\n  ]\n}\n```\n\n## Testing\n\n### Manual Testing\n```bash\n# Start dev server\nnpm run dev\n\n# Test endpoints with curl\ncurl \"http://localhost:3000/api/transactions\"\ncurl \"http://localhost:3000/api/transactions?person=Gabriel\"\ncurl \"http://localhost:3000/api/transactions?startDate=2025-01-01&endDate=2025-01-31\"\n```\n\n### In Browser\nOpen browser dev tools and check:\n1. Network tab for API requests\n2. Console for server logs (check terminal)\n3. Response data structure\n\n## Future Enhancements\n\n1. **Caching**: Implement Redis/memory cache for frequently accessed data\n2. **Analytics Endpoint**: Dedicated endpoint for dashboard analytics\n3. **Batch Operations**: Support for multiple simultaneous filters\n4. **Export Functionality**: CSV/PDF export via API\n5. **Real-time Updates**: WebSocket support for live transaction updates\n6. **Pagination**: Support for large datasets\n7. **Aggregation Endpoint**: Pre-calculated summaries and statistics\n\n## Security Notes\n\n- Google credentials remain server-side only (never exposed to client)\n- Input validation prevents injection attacks\n- Rate limiting can be added in future\n- CORS configured for Nuxt app only\n";export{n as default};
