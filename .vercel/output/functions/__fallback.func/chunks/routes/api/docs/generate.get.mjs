import{d as t,c as n}from"../../../nitro/nitro.mjs";import{readdir as e,readFile as r}from"fs/promises";import{resolve as s,join as o}from"path";import"node:http";import"node:https";import"node:events";import"node:buffer";import"node:fs";import"node:path";import"node:crypto";const a=t(async()=>{try{const t=s(process.cwd(),"server/api"),n=await scanApiEndpoints(t),a=s(process.cwd(),"server/utils"),i=await async function(t){const n=[];try{const s=await e(t,{withFileTypes:!0});for(const e of s)if(e.name.endsWith(".ts")&&!e.name.endsWith(".d.ts")){const s=o(t,e.name),a=extractExportedFunctions(await r(s,"utf-8"));n.push({file:e.name,path:`server/utils/${e.name}`,functions:a})}}catch(n){console.error(`Error scanning ${t}:`,n)}return n}(a),c=s(process.cwd(),"types/transaction.ts"),p=await async function(t){try{const n=await r(t,"utf-8"),e=[],s=/export interface (\w+) \{([\s\S]*?)\}/g;let o;for(;null!==(o=s.exec(n));){const[,t,n]=o,r=n.split("\n").filter(t=>t.trim()&&!t.trim().startsWith("//")).map(t=>t.trim());e.push({name:t,fields:r})}return{interfaces:e}}catch(n){return console.error(`Error reading ${t}:`,n),{interfaces:[]}}}(c);return{generatedAt:(new Date).toISOString(),endpoints:n,utilities:i,types:p,architecture:{layers:[{name:"Data Fetching Layer",location:"server/utils/googleSheets.ts",description:"Handles connection to Google Sheets API and fetches raw transaction data"},{name:"Transformation Layer",location:"server/utils/personIdentifier.ts",description:"Enriches transactions with person identification (Juliana/Gabriel)"},{name:"Processing Layer",location:"server/utils/installmentProcessor.ts",description:"Parses and expands installments across months"},{name:"Filtering Layer",location:"server/utils/transactionFilters.ts",description:"Applies filters based on query parameters"},{name:"API Endpoint",location:"server/api/transactions.get.ts",description:"Orchestrates all layers and handles HTTP requests"}]},markdown:generateMarkdown(n,i,p)}}catch(t){throw console.error("Error generating documentation:",t),n({statusCode:500,statusMessage:"Failed to generate documentation",data:{error:t instanceof Error?t.message:"Unknown error"}})}});async function scanApiEndpoints(t,n=""){var s;const a=[];try{const i=await e(t,{withFileTypes:!0});for(const e of i){const i=o(t,e.name);if(e.isDirectory()){const t=await scanApiEndpoints(i,o(n,e.name));a.push(...t)}else if(e.name.endsWith(".ts")&&!e.name.endsWith(".d.ts")){const t=await r(i,"utf-8"),c=(null==(s=e.name.replace(".ts","").split(".").pop())?void 0:s.toUpperCase())||"GET",p="/"+o(n,e.name.replace(/\.(get|post|put|delete|patch)\.ts$/,"")).replace(/\\/g,"/"),l=t.match(/\/\*\*([\s\S]*?)\*\//),f=l?l[1].trim():"",m=extractQueryParams(t);a.push({method:c,path:p,file:o(n,e.name).replace(/\\/g,"/"),description:cleanJSDoc(f),queryParams:m})}}}catch(n){console.error(`Error scanning ${t}:`,n)}return a}function extractQueryParams(t){const n=[],e=t.match(/const\s+\{([^}]+)\}\s*=\s*getQuery\(event\)/m);if(e){const t=e[1].split(",").map(t=>t.trim()).filter(t=>t.length>0);n.push(...t)}return n}function extractExportedFunctions(t){const n=[],e=/export\s+(?:async\s+)?function\s+(\w+)/g;let r;for(;null!==(r=e.exec(t));)n.push(r[1]);const s=/export\s+const\s+(\w+)\s*=/g;for(;null!==(r=s.exec(t));)n.push(r[1]);return n}function cleanJSDoc(t){return t.split("\n").map(t=>t.replace(/^\s*\*\s?/,"").trim()).filter(t=>t.length>0).join("\n")}function generateMarkdown(t,n,e){let r="# API Architecture Documentation (Auto-Generated)\n\n";r+=`*Generated at: ${(new Date).toISOString()}*\n\n`,r+="## API Endpoints\n\n";for(const n of t)if(r+=`### ${n.method} ${n.path}\n\n`,r+=`**File**: \`${n.file}\`\n\n`,n.description&&(r+=`${n.description}\n\n`),n.queryParams.length>0){r+="**Query Parameters**:\n";for(const t of n.queryParams)r+=`- \`${t}\`\n`;r+="\n"}r+="## Server Utilities\n\n";for(const t of n)if(r+=`### ${t.file}\n\n`,r+=`**Location**: \`${t.path}\`\n\n`,t.functions.length>0){r+="**Exported Functions**:\n";for(const n of t.functions)r+=`- \`${n}()\`\n`;r+="\n"}r+="## Type Definitions\n\n";for(const t of e.interfaces){r+=`### ${t.name}\n\n`,r+="```typescript\n",r+=`interface ${t.name} {\n`;for(const n of t.fields)r+=`  ${n}\n`;r+="}\n```\n\n"}return r}export{a as default};
